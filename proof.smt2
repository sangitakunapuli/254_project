; we need QF_UFBV for this proof
(set-logic QF_UFBV)

; insert the auto-generated code here
; SMT-LIBv2 description generated by Yosys 0.47 (git sha1 647d61dd9, clang++ 16.0.0 -fPIC -O3)
; yosys-smt2-module negate_submod
(declare-sort |negate_submod_s| 0)
(declare-fun |negate_submod_is| (|negate_submod_s|) Bool)
(declare-fun |negate_submod#0| (|negate_submod_s|) (_ BitVec 8)) ; \a
; yosys-smt2-input a 8
; yosys-smt2-witness {"offset": 0, "path": ["\\a"], "smtname": "a", "smtoffset": 0, "type": "input", "width": 8}
(define-fun |negate_submod_n a| ((state |negate_submod_s|)) (_ BitVec 8) (|negate_submod#0| state))
; yosys-smt2-output b 8
; yosys-smt2-witness {"offset": 0, "path": ["\\b"], "smtname": "b", "smtoffset": 0, "type": "blackbox", "width": 8}
(define-fun |negate_submod_n b| ((state |negate_submod_s|)) (_ BitVec 8) (let (
(|a| (|negate_submod_n a| state))
)
(bvnot a)
))
(define-fun |negate_submod_a| ((state |negate_submod_s|)) Bool true)
(define-fun |negate_submod_u| ((state |negate_submod_s|)) Bool true)
(define-fun |negate_submod_i| ((state |negate_submod_s|)) Bool true)
(define-fun |negate_submod_h| ((state |negate_submod_s|)) Bool true)
(define-fun |negate_submod_t| ((state |negate_submod_s|) (next_state |negate_submod_s|)) Bool true) ; end of module negate_submod
; yosys-smt2-module test
(declare-sort |test_s| 0)
(declare-fun |test_is| (|test_s|) Bool)
(declare-fun |test#0| (|test_s|) (_ BitVec 8)) ; \a_i
; yosys-smt2-input a_i 8
; yosys-smt2-witness {"offset": 0, "path": ["\\a_i"], "smtname": "a_i", "smtoffset": 0, "type": "input", "width": 8}
(define-fun |test_n a_i| ((state |test_s|)) (_ BitVec 8) (|test#0| state))
; yosys-smt2-cell negate_submod negate_instance
; yosys-smt2-witness {"path": ["\\negate_instance"], "smtname": "negate_instance", "type": "cell"}
(declare-fun |test#1| (|test_s|) (_ BitVec 8)) ; \b
(declare-fun |test_h negate_instance| (|test_s|) |negate_submod_s|)
(define-fun |test#2| ((state |test_s|)) (_ BitVec 8) (bvand (|test#1| state) (|test#0| state))) ; \b_o
; yosys-smt2-output b_o 8
(define-fun |test_n b_o| ((state |test_s|)) (_ BitVec 8) (|test#2| state))
(define-fun |test_a| ((state |test_s|)) Bool 
  (|negate_submod_a| (|test_h negate_instance| state))
)
(define-fun |test_u| ((state |test_s|)) Bool 
  (|negate_submod_u| (|test_h negate_instance| state))
)
(define-fun |test_i| ((state |test_s|)) Bool 
  (|negate_submod_i| (|test_h negate_instance| state))
)
(define-fun |test_h| ((state |test_s|)) Bool (and
  (= (|test_is| state) (|negate_submod_is| (|test_h negate_instance| state)))
  (= (|test#0| state) (|negate_submod_n a| (|test_h negate_instance| state))) ; negate_submod.a
  (= (|test#1| state) (|negate_submod_n b| (|test_h negate_instance| state))) ; negate_submod.b
  (|negate_submod_h| (|test_h negate_instance| state))
))
(define-fun |test_t| ((state |test_s|) (next_state |test_s|)) Bool 
  (|negate_submod_t| (|test_h negate_instance| state) (|test_h negate_instance| next_state))
) ; end of module test
; yosys-smt2-topmod test
; end of yosys output

; declare state variables s1
(declare-fun s1 () test_s)

(assert (= (|test_n b_o| s1)
		   (bvand
		     (bvnot (|test_n a_i| s1))
		     (|test_n a_i| s1))
             #b00000000))

; is there such a model?
(check-sat)
;(get-model)
