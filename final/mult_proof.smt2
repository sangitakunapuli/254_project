; we need QF_UFBV for this proof
(set-logic QF_UFBV)

; insert the auto-generated code here
; SMT-LIBv2 description generated by Yosys 0.47 (git sha1 647d61dd9, clang++ 16.0.0 -fPIC -O3)
; yosys-smt2-module mult
(declare-sort |mult_s| 0)
(declare-fun |mult_is| (|mult_s|) Bool)
(declare-fun |mult#0| (|mult_s|) (_ BitVec 128)) ; \a_i
; yosys-smt2-input a_i 128
; yosys-smt2-witness {"offset": 0, "path": ["\\a_i"], "smtname": "a_i", "smtoffset": 0, "type": "input", "width": 128}
(define-fun |mult_n a_i| ((state |mult_s|)) (_ BitVec 128) (|mult#0| state))
(declare-fun |mult#1| (|mult_s|) (_ BitVec 128)) ; \b_i
; yosys-smt2-input b_i 128
; yosys-smt2-witness {"offset": 0, "path": ["\\b_i"], "smtname": "b_i", "smtoffset": 0, "type": "input", "width": 128}
(define-fun |mult_n b_i| ((state |mult_s|)) (_ BitVec 128) (|mult#1| state))
; yosys-smt2-output s_o 128
; yosys-smt2-witness {"offset": 0, "path": ["\\s_o"], "smtname": "s_o", "smtoffset": 0, "type": "blackbox", "width": 128}
(define-fun |mult_n s_o| ((state |mult_s|)) (_ BitVec 128) (let (
(|a_i| (|mult_n a_i| state))
(|b_i| (|mult_n b_i| state))
)
(bvmul a_i b_i)
))
(define-fun |mult_a| ((state |mult_s|)) Bool true)
(define-fun |mult_u| ((state |mult_s|)) Bool true)
(define-fun |mult_i| ((state |mult_s|)) Bool true)
(define-fun |mult_h| ((state |mult_s|)) Bool true)
(define-fun |mult_t| ((state |mult_s|) (next_state |mult_s|)) Bool true) ; end of module mult
; end of yosys output

; declare state variables s1
(declare-fun s1 () mult_s)

(assert (not (= (|mult_n s_o| s1)
		   (bvmul
		     (|mult_n a_i| s1)
		     (|mult_n b_i| s1)))))

; is there such a model?
(check-sat)
;(get-model)
